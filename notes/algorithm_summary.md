# 算法笔记

## 算法性能分析

三个函数，时间复杂度分别是 $O(n)$ , $O(n^2)$ , $O(n\log n)$ ，使用加法运算来统一测试
```
fun1

输入 n (输入 0 退出): 10000
结果: 10000, 耗时: 83.3µs (0 ms)
------------------------------------
输入 n (输入 0 退出): 100000
结果: 100000, 耗时: 1.0276ms (1 ms)
------------------------------------
输入 n (输入 0 退出): 1000000
结果: 1000000, 耗时: 7.0643ms (7 ms)
------------------------------------

fun2 

输入 n (输入 0 退出): 10000
结果: 100000000, 耗时: 674.9276ms (674 ms)
------------------------------------
输入 n (输入 0 退出): 100000
结果: 10000000000, 耗时: 68.0148636s (68014 ms)
------------------------------------

fun3

输入 n (输入 0 退出): 10000
结果: 140000, 耗时: 541.1µs (0 ms)
------------------------------------
输入 n (输入 0 退出): 100000
结果: 1700000, 耗时: 4.9091ms (4 ms)
------------------------------------
输入 n (输入 0 退出): 1000000
结果: 20000000, 耗时: 62.5307ms (62 ms)
------------------------------------
```

## 数组

### 二分法

习惯定义 target 是在一个在左闭右闭的区间里，也就是[left, right]，所以始终坚持根据查找区间的定义来做边界处理即可

### 双指针

usize 还是 i32？

* Rust 的数组索引必须是 usize。

* usize 减法溢出隐患： 在 Java 中 int right = n - 1 如果减到 -1 没问题，但在 Rust 中，usize 类型是无符号的。如果 0 - 1 会直接导致程序 panic（崩溃）。