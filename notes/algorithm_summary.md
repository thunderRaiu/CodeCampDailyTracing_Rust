# 算法笔记

## 算法性能分析

三个函数，时间复杂度分别是 $O(n)$ , $O(n^2)$ , $O(n\log n)$ ，使用加法运算来统一测试

```
fun1

输入 n (输入 0 退出): 10000
结果: 10000, 耗时: 83.3µs (0 ms)
------------------------------------
输入 n (输入 0 退出): 100000
结果: 100000, 耗时: 1.0276ms (1 ms)
------------------------------------
输入 n (输入 0 退出): 1000000
结果: 1000000, 耗时: 7.0643ms (7 ms)
------------------------------------

fun2 

输入 n (输入 0 退出): 10000
结果: 100000000, 耗时: 674.9276ms (674 ms)
------------------------------------
输入 n (输入 0 退出): 100000
结果: 10000000000, 耗时: 68.0148636s (68014 ms)
------------------------------------

fun3

输入 n (输入 0 退出): 10000
结果: 140000, 耗时: 541.1µs (0 ms)
------------------------------------
输入 n (输入 0 退出): 100000
结果: 1700000, 耗时: 4.9091ms (4 ms)
------------------------------------
输入 n (输入 0 退出): 1000000
结果: 20000000, 耗时: 62.5307ms (62 ms)
------------------------------------
```

## 数组

### 二分法

习惯定义 target 是在一个在左闭右闭的区间里，也就是[left, right]，所以始终坚持根据查找区间的定义来做边界处理即可

### 双指针

usize 还是 i32？

* Rust 的数组索引必须是 usize。

* usize 减法溢出隐患： 在 Java 中 int right = n - 1 如果减到 -1 没问题，但在 Rust 中，usize 类型是无符号的。如果 0 - 1 会直接导致程序 panic（崩溃）。

### 滑动窗口

滑动窗口比暴力法优雅de原因

**暴力法**：双重 for 循环，时间复杂度 $O(n^2)$。

**滑动窗口**：虽然里面有个 while，但每个元素在整个过程中只被 right 访问一次，被 left 访问一次。总的操作次数是 $2n$，所以时间复杂度是 $O(n)$。

### 边界条件（循环不变量原则）

坚持 “左闭右开”

### 前缀和

区间计算公式的准确性

* 核心公式：区间` [i, j] `的和 `= p[j] - p[i-1]`。

* 易错点：当 `i = 0`时，`p[i-1]`会导致下标越界。

* 解决建议：

  * 方法 A（逻辑判断）：手动处理 `if i == 0 { p[j] }`。

  * 方法 B（偏移一位）：构建前缀和数组时长度设为`n + 1`，令 `p[0] = 0`。这样区间 `[i, j]`的和统一为 `p[j+1] - p[i]`。这种方法在处理二维前缀和时尤其好用。

数据溢出（Overflow）如果原数组元素是 `i32`，且数组长度很大（如 $10^5$），前缀和可能会超过 `i32` 的最大值。

* 解决建议：存储前缀和的数组建议使用 `i64` 或 `isize`以防万一。

场景适用性

* 前缀和适用于原始数组不会被修改，但需要频繁查询区间和的场景。

* 如果数组元素会频繁更新，前缀和每次更新需要 $O(n)$，此时应考虑树状数组（Binary Indexed Tree）或线段树（Segment Tree）。

### 前缀和的平面化

无论怎么切，分成的两块面积之和永远等于总和 total_sum

公式推导：设第一块区域和为 $S_1$，第二块区域和为 $S_2$。已知 $S_1 + S_2 = TotalSum \Rightarrow S_2 = TotalSum - S_1$。要最小化 $|S_1 - S_2|$，代入得：$|S_1 - (TotalSum - S_1)| = |2S_1 - TotalSum|$。  `abs(total_sum - 2 * count)`
